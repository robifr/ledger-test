/**
 * Copyright 2024 Robi
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.robifr.ledger.data.model

import android.os.Parcelable
import androidx.room.ColumnInfo
import androidx.room.Entity
import androidx.room.ForeignKey
import androidx.room.Ignore
import androidx.room.Index
import androidx.room.PrimaryKey
import androidx.room.TypeConverters
import com.robifr.ledger.local.ColumnConverter.BigDecimalConverter
import java.math.BigDecimal
import java.math.RoundingMode
import kotlinx.parcelize.Parcelize

/**
 * @param id Product order unique ID. Set to null for the value to be auto-generated by Room. See
 *   [Model.modelId] For the reason of why it's boxed type.
 * @param queueId Referenced queue ID from [QueueModel.id].
 * @param productId Referenced product ID from [ProductModel.id].
 * @param productName Referenced product name if [productId] exists from [ProductModel.name].
 * @param productPrice Referenced product price if [productId] exists from [ProductModel.price].
 * @param quantity Product order quantity.
 * @param discount Product order discount.
 * @param totalPrice Product order total price. Use [ProductOrderModel.calculateTotalPrice] to do
 *   the calculation.
 */
@JvmRecord
@Parcelize
@Entity(
    tableName = "product_order",
    foreignKeys =
        [
            ForeignKey(
                entity = QueueModel::class,
                parentColumns = ["id"],
                childColumns = ["queue_id"],
                onUpdate = ForeignKey.CASCADE,
                onDelete = ForeignKey.CASCADE),
            ForeignKey(
                entity = ProductModel::class,
                parentColumns = ["id"],
                childColumns = ["product_id"],
                onUpdate = ForeignKey.CASCADE,
                onDelete = ForeignKey.SET_NULL)],
    indices = [Index(value = ["queue_id"]), Index(value = ["product_id"])])
data class ProductOrderModel(
    @PrimaryKey(autoGenerate = true) @ColumnInfo(name = "id") val id: Long? = null,
    @ColumnInfo(name = "queue_id") val queueId: Long? = null,
    @ColumnInfo(name = "product_id") val productId: Long? = null,
    @ColumnInfo(name = "product_name") val productName: String? = null,
    @ColumnInfo(name = "product_price") val productPrice: Long? = null,
    @ColumnInfo(name = "quantity") val quantity: Double = 0.0,
    @ColumnInfo(name = "discount") val discount: Long = 0L,
    @field:TypeConverters(BigDecimalConverter::class)
    @ColumnInfo(name = "total_price")
    val totalPrice: BigDecimal = calculateTotalPrice(productPrice, quantity, discount)
) : Model, Parcelable {
  @Ignore override fun modelId(): Long? = id

  @Ignore fun withId(id: Long?): ProductOrderModel = copy(id = id)

  @Ignore fun withQueueId(queueId: Long?): ProductOrderModel = copy(queueId = queueId)

  @Ignore fun withProductId(productId: Long?): ProductOrderModel = copy(productId = productId)

  @Ignore
  fun withProductName(productName: String?): ProductOrderModel = copy(productName = productName)

  @Ignore
  fun withProductPrice(productPrice: Long?): ProductOrderModel = copy(productPrice = productPrice)

  @Ignore fun withQuantity(quantity: Double): ProductOrderModel = copy(quantity = quantity)

  @Ignore fun withDiscount(discount: Long): ProductOrderModel = copy(discount = discount)

  @Ignore
  fun withTotalPrice(totalPrice: BigDecimal): ProductOrderModel = copy(totalPrice = totalPrice)

  /**
   * @return Referenced product associated with the current product order. [productId] will remains
   *   null if its null, which can occur when the actual product has been deleted from the database.
   *   However, other fields such as [productName] and [productPrice] are retained to preserve
   *   transaction history.
   */
  @Ignore
  fun referencedProduct(): ProductModel? =
      productName?.let { productPrice?.let { ProductModel(productId, productName, productPrice) } }

  @Ignore
  fun discountPercent(): BigDecimal {
    val totalPriceWithoutDiscount: BigDecimal = totalPrice + discount.toBigDecimal()
    return if (totalPriceWithoutDiscount.compareTo(0.toBigDecimal()) == 0) {
      0.toBigDecimal() // Prevent zero division.
    } else {
      (discount.toBigDecimal() * 100.toBigDecimal())
          .divide(totalPriceWithoutDiscount, 2, RoundingMode.UP)
          .stripTrailingZeros()
    }
  }

  companion object {
    @JvmStatic fun toBuilder(): ProductOrderModel = ProductOrderModel()

    @JvmStatic
    fun calculateTotalPrice(productPrice: Long?, quantity: Double, discount: Long): BigDecimal {
      val totalPrice: BigDecimal =
          productPrice
              ?.toBigDecimal()
              ?.multiply(quantity.toBigDecimal())
              ?.subtract(discount.toBigDecimal()) ?: 0.toBigDecimal()
      return maxOf(0.toBigDecimal(), totalPrice) // Disallow negative total price.
    }
  }
}
